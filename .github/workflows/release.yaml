name: CI/CD - Manual Version Tag and Release

on:
  push:
    branches:
      - main # Or your production branch, e.g., production

permissions:
  contents: write   # To create tags and releases

jobs:
  tag-and-release:
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.versioner.outputs.new_version }}
      image_uri: ${{ steps.build-image.outputs.image_uri }} # Output for potential downstream jobs

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Required to get all tags and commit history
      - name: Bump version and push tag
        id: versioner
        uses: mathieudutour/github-tag-action@v6.2
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
      # - name: Configure Git User
      #   run: |
      #     git config user.name "${{ github.actor }}"
      #     git config user.email "${{ github.actor }}@users.noreply.github.com"
      #
      # - name: Get Latest Commit Message
      #   id: commit_message
      #   run: echo "message=$(git log -1 --pretty=%B)" >> $GITHUB_OUTPUT
      #
      # - name: Calculate Next Version and Create Tag
      #   id: versioner
      #   run: |
      #     # Fetch all tags
      #     git fetch --tags --force
      #
      #     LATEST_TAG=$(git describe --tags `git rev-list --tags --max-count=1` 2>/dev/null || echo "v0.0.0") # Default if no tags
      #     LATEST_TAG_CLEAN=${LATEST_TAG#v} # Remove 'v' prefix if present
      #
      #     IFS='.' read -r -a VERSION_PARTS <<< "$LATEST_TAG_CLEAN"
      #     MAJOR=${VERSION_PARTS[0]:-0}
      #     MINOR=${VERSION_PARTS[1]:-0}
      #     PATCH=${VERSION_PARTS[2]:-0}
      #
      #     COMMIT_MSG="${{ steps.commit_message.outputs.message }}"
      #
      #     if [[ "$COMMIT_MSG" == *"[major]"* ]] || [[ "$COMMIT_MSG" == *"#major"* ]]; then
      #       MAJOR=$((MAJOR + 1))
      #       MINOR=0
      #       PATCH=0
      #     elif [[ "$COMMIT_MSG" == *"[minor]"* ]] || [[ "$COMMIT_MSG" == *"#minor"* ]]; then
      #       MINOR=$((MINOR + 1))
      #       PATCH=0
      #     else # Default to patch
      #       PATCH=$((PATCH + 1))
      #     fi
      #
      #     # Handle initial version case where LATEST_TAG was v0.0.0 and no keyword specified
      #     if [[ "$LATEST_TAG" == "v0.0.0" ]] && [[ "$MAJOR" -eq 0 ]] && [[ "$MINOR" -eq 0 ]] && [[ "$PATCH" -eq 1 ]]; then
      #       MAJOR=0
      #       MINOR=1
      #       PATCH=0
      #     fi
      #
      #     NEW_VERSION="v$MAJOR.$MINOR.$PATCH"
      #     echo "Current latest tag: $LATEST_TAG"
      #     echo "Determined new version: $NEW_VERSION"
      #     echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
      #
      #     # Create and push Git tag
      #     git tag "$NEW_VERSION" -m "Release $NEW_VERSION"
      #     git push origin "$NEW_VERSION"

      # - name: Configure AWS credentials (for ECR)
      #   uses: aws-actions/configure-aws-credentials@v4
      #   with:
      #     role-to-assume: arn:aws:iam::YOUR_AWS_ACCOUNT_ID:role/YOUR_GITHUB_ACTIONS_ECR_ROLE # Replace with your actual Role ARN
      #     aws-region: YOUR_AWS_REGION # e.g., us-east-1
      #
      # - name: Login to Amazon ECR
      #   id: login-ecr
      #   uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push Docker image to ECR
        id: build-image
        env:
          ECR_REGISTRY: "ecr-registry" 
          IMAGE_NAME: your-app-name # Replace with your ECR image name
          IMAGE_TAG: ${{ steps.versioner.outputs.new_tag }}
        run: |
          docker build -t $ECR_REGISTRY/$IMAGE_NAME:$IMAGE_TAG .
          # Optionally, also tag as 'latest'
          docker tag $ECR_REGISTRY/$IMAGE_NAME:$IMAGE_TAG $ECR_REGISTRY/$IMAGE_NAME:latest

          # docker push $ECR_REGISTRY/$IMAGE_NAME:$IMAGE_TAG
          # docker push $ECR_REGISTRY/$IMAGE_NAME:latest # Push 'latest' tag

          echo "Pushed ECR Image: $ECR_REGISTRY/$IMAGE_NAME:$IMAGE_TAG"
          echo "image_uri=$ECR_REGISTRY/$IMAGE_NAME:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.versioner.outputs.new_tag }}
          release_name: Release ${{ steps.versioner.outputs.new_tag }}
          body: |
            Released version ${{ steps.versioner.outputs.new_tag }}

            **Changes:**
            ${{ steps.versioner.outputs.changelog }}
            
            **Docker Image:**
            `${{ steps.build-image.outputs.image_uri }}`
          draft: true
          prerelease: true
